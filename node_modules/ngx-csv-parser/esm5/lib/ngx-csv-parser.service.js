import { __assign, __decorate, __values } from "tslib";
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxCSVParserError } from './_model/ngx-csv-parser-error.interface';
import * as i0 from "@angular/core";
var NgxCsvParser = /** @class */ (function () {
    function NgxCsvParser() {
        this.defaultCSVParserConfig = {
            header: true,
            delimiter: ','
        };
        console.log("\n      *****************************************************\n      ***      For Custom Software/Web development      ***\n      *** Reach out to us at contact@developershive.com ***\n      ***  Support us https://patreon.com/tofiqquadri/  ***\n      ***     Visit us at https://developershive.com    ***\n      *****************************************************\n    ");
    }
    NgxCsvParser.prototype.parse = function (csvFile, config) {
        var _this = this;
        config = __assign(__assign({}, this.defaultCSVParserConfig), config);
        var ngxCSVParserObserver = new Observable(function (observer) {
            try {
                var csvRecords_1 = null;
                if (_this.isCSVFile(csvFile)) {
                    var reader_1 = new FileReader();
                    reader_1.readAsText(csvFile);
                    reader_1.onload = function () {
                        var csvData = reader_1.result;
                        var csvRecordsArray = _this.csvStringToArray(csvData.trim(), config.delimiter);
                        var headersRow = _this.getHeaderArray(csvRecordsArray);
                        csvRecords_1 = _this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);
                        observer.next(csvRecords_1);
                        observer.complete();
                    };
                    reader_1.onerror = function () {
                        _this.badCSVDataFormatErrorHandler(observer);
                    };
                }
                else {
                    _this.notCSVFileErrorHandler(observer);
                }
            }
            catch (error) {
                _this.unknownCSVParserErrorHandler(observer);
            }
        });
        return ngxCSVParserObserver;
    };
    NgxCsvParser.prototype.csvStringToArray = function (csvDataString, delimiter) {
        var regexPattern = new RegExp(("(\\" + delimiter + "|\\r?\\n|\\r|^)(?:\"((?:\\\\.|\"\"|[^\\\\\"])*)\"|([^\\" + delimiter + "\"\\r\\n]*))"), "gi");
        var matchedPatternArray = regexPattern.exec(csvDataString);
        var resultCSV = [[]];
        while (matchedPatternArray) {
            if (matchedPatternArray[1].length && matchedPatternArray[1] !== delimiter) {
                resultCSV.push([]);
            }
            var cleanValue = matchedPatternArray[2] ?
                matchedPatternArray[2].replace(new RegExp("[\\\\\"](.)", "g"), '$1') : matchedPatternArray[3];
            resultCSV[resultCSV.length - 1].push(cleanValue);
            matchedPatternArray = regexPattern.exec(csvDataString);
        }
        return resultCSV;
    };
    NgxCsvParser.prototype.getDataRecordsArrayFromCSVFile = function (csvRecordsArray, headerLength, config) {
        var dataArr = [];
        var headersArray = csvRecordsArray[0];
        var startingRowToParseData = config.header ? 1 : 0;
        for (var i = startingRowToParseData; i < csvRecordsArray.length; i++) {
            var data = csvRecordsArray[i];
            if (data.length === headerLength && config.header) {
                var csvRecord = {};
                for (var j = 0; j < data.length; j++) {
                    if ((data[j] === undefined) || (data[j] === null)) {
                        csvRecord[headersArray[j]] = "";
                    }
                    else {
                        csvRecord[headersArray[j]] = data[j].trim();
                    }
                }
                dataArr.push(csvRecord);
            }
            else {
                dataArr.push(data);
            }
        }
        return dataArr;
    };
    NgxCsvParser.prototype.isCSVFile = function (file) {
        return file.name.endsWith('.csv');
    };
    NgxCsvParser.prototype.getHeaderArray = function (csvRecordsArr) {
        var e_1, _a;
        var headers = csvRecordsArr[0];
        var headerArray = [];
        try {
            for (var headers_1 = __values(headers), headers_1_1 = headers_1.next(); !headers_1_1.done; headers_1_1 = headers_1.next()) {
                var header = headers_1_1.value;
                headerArray.push(header);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (headers_1_1 && !headers_1_1.done && (_a = headers_1.return)) _a.call(headers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return headerArray;
    };
    NgxCsvParser.prototype.notCSVFileErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.unknownCSVParserErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.badCSVDataFormatErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.errorBuilder = function (type, message, code) {
        var ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = type;
        ngcCSVParserError.message = message;
        ngcCSVParserError.code = code;
        return ngcCSVParserError;
    };
    NgxCsvParser.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgxCsvParser_Factory() { return new NgxCsvParser(); }, token: NgxCsvParser, providedIn: "root" });
    NgxCsvParser = __decorate([
        Injectable({
            providedIn: 'root'
        })
    ], NgxCsvParser);
    return NgxCsvParser;
}());
export { NgxCsvParser };
var CSVParserConfig = /** @class */ (function () {
    function CSVParserConfig() {
    }
    return CSVParserConfig;
}());
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNzdi1wYXJzZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1jc3YtcGFyc2VyLyIsInNvdXJjZXMiOlsibGliL25neC1jc3YtcGFyc2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBWSxNQUFNLE1BQU0sQ0FBQztBQUM1QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQzs7QUFLNUU7SUFFSTtRQVdRLDJCQUFzQixHQUFHO1lBQzdCLE1BQU0sRUFBRSxJQUFJO1lBQ1osU0FBUyxFQUFFLEdBQUc7U0FDakIsQ0FBQztRQWJFLE9BQU8sQ0FBQyxHQUFHLENBQUMsc1hBT2YsQ0FBQyxDQUFDO0lBQ0gsQ0FBQztJQU9ELDRCQUFLLEdBQUwsVUFBTSxPQUFhLEVBQUUsTUFBdUI7UUFBNUMsaUJBMENDO1FBeENHLE1BQU0seUJBQ0MsSUFBSSxDQUFDLHNCQUFzQixHQUMzQixNQUFNLENBQ1osQ0FBQztRQUVGLElBQU0sb0JBQW9CLEdBQUcsSUFBSSxVQUFVLENBQUMsVUFBQyxRQUFrRDtZQUMzRixJQUFJO2dCQUNBLElBQUksWUFBVSxHQUFHLElBQUksQ0FBQztnQkFFdEIsSUFBSSxLQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUV6QixJQUFNLFFBQU0sR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO29CQUNoQyxRQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUUzQixRQUFNLENBQUMsTUFBTSxHQUFHO3dCQUNaLElBQU0sT0FBTyxHQUFHLFFBQU0sQ0FBQyxNQUFNLENBQUM7d0JBQzlCLElBQU0sZUFBZSxHQUFHLEtBQUksQ0FBQyxnQkFBZ0IsQ0FBRSxPQUFrQixDQUFDLElBQUksRUFBRSxFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQzt3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bURBQTRCLEdBQTVCLFVBQTZCLFFBQXVCO1FBQ2hELElBQU0saUJBQWlCLEdBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxFQUFFLDBFQUEwRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3hILFFBQVEsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsbURBQTRCLEdBQTVCLFVBQTZCLFFBQXVCO1FBQ2hELElBQU0saUJBQWlCLEdBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDN0UsUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxtQ0FBWSxHQUFaLFVBQWEsSUFBWSxFQUFFLE9BQVksRUFBRSxJQUFTO1FBQzlDLElBQU0saUJBQWlCLEdBQXNCLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUNyRSxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQzlCLGlCQUFpQixDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDcEMsaUJBQWlCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUM5QixPQUFPLGlCQUFpQixDQUFDO0lBQzdCLENBQUM7O0lBL0lRLFlBQVk7UUFIeEIsVUFBVSxDQUFDO1lBQ1IsVUFBVSxFQUFFLE1BQU07U0FDckIsQ0FBQztPQUNXLFlBQVksQ0FnSnhCO3VCQXZKRDtDQXVKQyxBQWhKRCxJQWdKQztTQWhKWSxZQUFZO0FBa0p6QjtJQUlJO0lBQWdCLENBQUM7SUFDckIsc0JBQUM7QUFBRCxDQUFDLEFBTEQsSUFLQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgTmd4Q1NWUGFyc2VyRXJyb3IgfSBmcm9tICcuL19tb2RlbC9uZ3gtY3N2LXBhcnNlci1lcnJvci5pbnRlcmZhY2UnO1xyXG5cclxuQEluamVjdGFibGUoe1xyXG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ3hDc3ZQYXJzZXIge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBcclxuICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgKioqICAgICAgRm9yIEN1c3RvbSBTb2Z0d2FyZS9XZWIgZGV2ZWxvcG1lbnQgICAgICAqKipcclxuICAgICAgKioqIFJlYWNoIG91dCB0byB1cyBhdCBjb250YWN0QGRldmVsb3BlcnNoaXZlLmNvbSAqKipcclxuICAgICAgKioqICBTdXBwb3J0IHVzIGh0dHBzOi8vcGF0cmVvbi5jb20vdG9maXFxdWFkcmkvICAqKipcclxuICAgICAgKioqICAgICBWaXNpdCB1cyBhdCBodHRwczovL2RldmVsb3BlcnNoaXZlLmNvbSAgICAqKipcclxuICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIGApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZGVmYXVsdENTVlBhcnNlckNvbmZpZyA9IHtcclxuICAgICAgICBoZWFkZXI6IHRydWUsXHJcbiAgICAgICAgZGVsaW1pdGVyOiAnLCdcclxuICAgIH07XHJcblxyXG4gICAgcGFyc2UoY3N2RmlsZTogRmlsZSwgY29uZmlnOiBDU1ZQYXJzZXJDb25maWcpOiBPYnNlcnZhYmxlPEFycmF5PGFueT4gfCBOZ3hDU1ZQYXJzZXJFcnJvcj4ge1xyXG5cclxuICAgICAgICBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdENTVlBhcnNlckNvbmZpZyxcclxuICAgICAgICAgICAgLi4uY29uZmlnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgbmd4Q1NWUGFyc2VyT2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEFycmF5PGFueT4gfCBOZ3hDU1ZQYXJzZXJFcnJvcj4pID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGxldCBjc3ZSZWNvcmRzID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NTVkZpbGUoY3N2RmlsZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChjc3ZGaWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3N2RGF0YSA9IHJlYWRlci5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzdlJlY29yZHNBcnJheSA9IHRoaXMuY3N2U3RyaW5nVG9BcnJheSgoY3N2RGF0YSBhcyBzdHJpbmcpLnRyaW0oKSwgY29uZmlnLmRlbGltaXRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzUm93ID0gdGhpcy5nZXRIZWFkZXJBcnJheShjc3ZSZWNvcmRzQXJyYXkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3N2UmVjb3JkcyA9IHRoaXMuZ2V0RGF0YVJlY29yZHNBcnJheUZyb21DU1ZGaWxlKGNzdlJlY29yZHNBcnJheSwgaGVhZGVyc1Jvdy5sZW5ndGgsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGNzdlJlY29yZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhZENTVkRhdGFGb3JtYXRFcnJvckhhbmRsZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdENTVkZpbGVFcnJvckhhbmRsZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5rbm93bkNTVlBhcnNlckVycm9ySGFuZGxlcihvYnNlcnZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5neENTVlBhcnNlck9ic2VydmVyO1xyXG4gICAgfVxyXG5cclxuICAgIGNzdlN0cmluZ1RvQXJyYXkoY3N2RGF0YVN0cmluZzogc3RyaW5nLCBkZWxpbWl0ZXI6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHJlZ2V4UGF0dGVybiA9IG5ldyBSZWdFeHAoKGAoXFxcXCR7ZGVsaW1pdGVyfXxcXFxccj9cXFxcbnxcXFxccnxeKSg/OlxcXCIoKD86XFxcXFxcXFwufFxcXCJcXFwifFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFteXFxcXCR7ZGVsaW1pdGVyfVxcXCJcXFxcclxcXFxuXSopKWApLCBcImdpXCIpXHJcbiAgICAgICAgbGV0IG1hdGNoZWRQYXR0ZXJuQXJyYXkgPSByZWdleFBhdHRlcm4uZXhlYyhjc3ZEYXRhU3RyaW5nKTtcclxuICAgICAgICBjb25zdCByZXN1bHRDU1YgPSBbW11dO1xyXG4gICAgICAgIHdoaWxlIChtYXRjaGVkUGF0dGVybkFycmF5KSB7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGVkUGF0dGVybkFycmF5WzFdLmxlbmd0aCAmJiBtYXRjaGVkUGF0dGVybkFycmF5WzFdICE9PSBkZWxpbWl0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdENTVi5wdXNoKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjbGVhblZhbHVlID0gbWF0Y2hlZFBhdHRlcm5BcnJheVsyXSA/XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkUGF0dGVybkFycmF5WzJdLnJlcGxhY2UobmV3IFJlZ0V4cChcIltcXFxcXFxcXFxcXCJdKC4pXCIsIFwiZ1wiKSwgJyQxJykgOiBtYXRjaGVkUGF0dGVybkFycmF5WzNdO1xyXG4gICAgICAgICAgICByZXN1bHRDU1ZbcmVzdWx0Q1NWLmxlbmd0aCAtIDFdLnB1c2goY2xlYW5WYWx1ZSk7XHJcbiAgICAgICAgICAgIG1hdGNoZWRQYXR0ZXJuQXJyYXkgPSByZWdleFBhdHRlcm4uZXhlYyhjc3ZEYXRhU3RyaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdENTVjtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRhUmVjb3Jkc0FycmF5RnJvbUNTVkZpbGUoY3N2UmVjb3Jkc0FycmF5OiBhbnksIGhlYWRlckxlbmd0aDogYW55LCBjb25maWc6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFBcnIgPSBbXTtcclxuICAgICAgICBjb25zdCBoZWFkZXJzQXJyYXkgPSBjc3ZSZWNvcmRzQXJyYXlbMF07XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXJ0aW5nUm93VG9QYXJzZURhdGEgPSBjb25maWcuaGVhZGVyID8gMSA6IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydGluZ1Jvd1RvUGFyc2VEYXRhOyBpIDwgY3N2UmVjb3Jkc0FycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjc3ZSZWNvcmRzQXJyYXlbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IGhlYWRlckxlbmd0aCAmJiBjb25maWcuaGVhZGVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY3N2UmVjb3JkID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkYXRhLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhW2pdID09PSB1bmRlZmluZWQpIHx8IChkYXRhW2pdID09PSBudWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3ZSZWNvcmRbaGVhZGVyc0FycmF5W2pdXSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3N2UmVjb3JkW2hlYWRlcnNBcnJheVtqXV0gPSBkYXRhW2pdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkYXRhQXJyLnB1c2goY3N2UmVjb3JkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGFBcnIucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YUFycjtcclxuICAgIH1cclxuXHJcbiAgICBpc0NTVkZpbGUoZmlsZTogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGUubmFtZS5lbmRzV2l0aCgnLmNzdicpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEhlYWRlckFycmF5KGNzdlJlY29yZHNBcnI6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBjc3ZSZWNvcmRzQXJyWzBdO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlckFycmF5ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xyXG4gICAgICAgICAgICBoZWFkZXJBcnJheS5wdXNoKGhlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXJBcnJheTtcclxuICAgIH1cclxuXHJcbiAgICBub3RDU1ZGaWxlRXJyb3JIYW5kbGVyKG9ic2VydmVyOiBPYnNlcnZlcjxhbnk+KSB7XHJcbiAgICAgICAgY29uc3QgbmdjQ1NWUGFyc2VyRXJyb3I6IE5neENTVlBhcnNlckVycm9yID1cclxuICAgICAgICAgICAgdGhpcy5lcnJvckJ1aWxkZXIoJ05PVF9BX0NTVl9GSUxFJywgJ1NlbGVjdGVkIGZpbGUgaXMgbm90IGEgY3N2IEZpbGUgVHlwZS4nLCAyKTtcclxuICAgICAgICBvYnNlcnZlci5lcnJvcihuZ2NDU1ZQYXJzZXJFcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdW5rbm93bkNTVlBhcnNlckVycm9ySGFuZGxlcihvYnNlcnZlcjogT2JzZXJ2ZXI8YW55Pikge1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCdWlsZGVyKCdVTktOT1dOX0VSUk9SJywgJ1Vua25vd24gZXJyb3IuIFBsZWFzZSByZWZlciB0byBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIGZvciBsaWJyYXJ5IHVzYWdlLicsIDQwNCk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGJhZENTVkRhdGFGb3JtYXRFcnJvckhhbmRsZXIob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pIHtcclxuICAgICAgICBjb25zdCBuZ2NDU1ZQYXJzZXJFcnJvcjogTmd4Q1NWUGFyc2VyRXJyb3IgPVxyXG4gICAgICAgICAgICB0aGlzLmVycm9yQnVpbGRlcignQkFEX0NTVl9EQVRBX0ZPUk1BVCcsICdVbmFibGUgdG8gcGFyc2UgQ1NWIEZpbGUuJywgMSk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGVycm9yQnVpbGRlcih0eXBlOiBzdHJpbmcsIG1lc3NhZ2U6IGFueSwgY29kZTogYW55KTogTmd4Q1NWUGFyc2VyRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9IG5ldyBOZ3hDU1ZQYXJzZXJFcnJvcigpO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHJldHVybiBuZ2NDU1ZQYXJzZXJFcnJvcjtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgQ1NWUGFyc2VyQ29uZmlnIHtcclxuICAgIGhlYWRlcj86IGJvb2xlYW47XHJcbiAgICBkZWxpbWl0ZXI/OiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7IH1cclxufVxyXG4iXX0=