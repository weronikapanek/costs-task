import { __assign, __values, __decorate } from 'tslib';
import { ɵɵdefineInjectable, Injectable, Component, NgModule } from '@angular/core';
import { Observable } from 'rxjs';

var NgxCSVParserError = /** @class */ (function () {
    function NgxCSVParserError() {
    }
    return NgxCSVParserError;
}());

var NgxCsvParser = /** @class */ (function () {
    function NgxCsvParser() {
        this.defaultCSVParserConfig = {
            header: true,
            delimiter: ','
        };
        console.log("\n      *****************************************************\n      ***      For Custom Software/Web development      ***\n      *** Reach out to us at contact@developershive.com ***\n      ***  Support us https://patreon.com/tofiqquadri/  ***\n      ***     Visit us at https://developershive.com    ***\n      *****************************************************\n    ");
    }
    NgxCsvParser.prototype.parse = function (csvFile, config) {
        var _this = this;
        config = __assign(__assign({}, this.defaultCSVParserConfig), config);
        var ngxCSVParserObserver = new Observable(function (observer) {
            try {
                var csvRecords_1 = null;
                if (_this.isCSVFile(csvFile)) {
                    var reader_1 = new FileReader();
                    reader_1.readAsText(csvFile);
                    reader_1.onload = function () {
                        var csvData = reader_1.result;
                        var csvRecordsArray = _this.csvStringToArray(csvData.trim(), config.delimiter);
                        var headersRow = _this.getHeaderArray(csvRecordsArray);
                        csvRecords_1 = _this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);
                        observer.next(csvRecords_1);
                        observer.complete();
                    };
                    reader_1.onerror = function () {
                        _this.badCSVDataFormatErrorHandler(observer);
                    };
                }
                else {
                    _this.notCSVFileErrorHandler(observer);
                }
            }
            catch (error) {
                _this.unknownCSVParserErrorHandler(observer);
            }
        });
        return ngxCSVParserObserver;
    };
    NgxCsvParser.prototype.csvStringToArray = function (csvDataString, delimiter) {
        var regexPattern = new RegExp(("(\\" + delimiter + "|\\r?\\n|\\r|^)(?:\"((?:\\\\.|\"\"|[^\\\\\"])*)\"|([^\\" + delimiter + "\"\\r\\n]*))"), "gi");
        var matchedPatternArray = regexPattern.exec(csvDataString);
        var resultCSV = [[]];
        while (matchedPatternArray) {
            if (matchedPatternArray[1].length && matchedPatternArray[1] !== delimiter) {
                resultCSV.push([]);
            }
            var cleanValue = matchedPatternArray[2] ?
                matchedPatternArray[2].replace(new RegExp("[\\\\\"](.)", "g"), '$1') : matchedPatternArray[3];
            resultCSV[resultCSV.length - 1].push(cleanValue);
            matchedPatternArray = regexPattern.exec(csvDataString);
        }
        return resultCSV;
    };
    NgxCsvParser.prototype.getDataRecordsArrayFromCSVFile = function (csvRecordsArray, headerLength, config) {
        var dataArr = [];
        var headersArray = csvRecordsArray[0];
        var startingRowToParseData = config.header ? 1 : 0;
        for (var i = startingRowToParseData; i < csvRecordsArray.length; i++) {
            var data = csvRecordsArray[i];
            if (data.length === headerLength && config.header) {
                var csvRecord = {};
                for (var j = 0; j < data.length; j++) {
                    if ((data[j] === undefined) || (data[j] === null)) {
                        csvRecord[headersArray[j]] = "";
                    }
                    else {
                        csvRecord[headersArray[j]] = data[j].trim();
                    }
                }
                dataArr.push(csvRecord);
            }
            else {
                dataArr.push(data);
            }
        }
        return dataArr;
    };
    NgxCsvParser.prototype.isCSVFile = function (file) {
        return file.name.endsWith('.csv');
    };
    NgxCsvParser.prototype.getHeaderArray = function (csvRecordsArr) {
        var e_1, _a;
        var headers = csvRecordsArr[0];
        var headerArray = [];
        try {
            for (var headers_1 = __values(headers), headers_1_1 = headers_1.next(); !headers_1_1.done; headers_1_1 = headers_1.next()) {
                var header = headers_1_1.value;
                headerArray.push(header);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (headers_1_1 && !headers_1_1.done && (_a = headers_1.return)) _a.call(headers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return headerArray;
    };
    NgxCsvParser.prototype.notCSVFileErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.unknownCSVParserErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.badCSVDataFormatErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.errorBuilder = function (type, message, code) {
        var ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = type;
        ngcCSVParserError.message = message;
        ngcCSVParserError.code = code;
        return ngcCSVParserError;
    };
    NgxCsvParser.ɵprov = ɵɵdefineInjectable({ factory: function NgxCsvParser_Factory() { return new NgxCsvParser(); }, token: NgxCsvParser, providedIn: "root" });
    NgxCsvParser = __decorate([
        Injectable({
            providedIn: 'root'
        })
    ], NgxCsvParser);
    return NgxCsvParser;
}());
var CSVParserConfig = /** @class */ (function () {
    function CSVParserConfig() {
    }
    return CSVParserConfig;
}());

var NgxCsvParserComponent = /** @class */ (function () {
    function NgxCsvParserComponent() {
    }
    NgxCsvParserComponent.prototype.ngOnInit = function () {
    };
    NgxCsvParserComponent = __decorate([
        Component({
            selector: 'lib-ngx-csv-parser',
            template: "\n    <p>\n      ngx-csv-parser works!\n    </p>\n  "
        })
    ], NgxCsvParserComponent);
    return NgxCsvParserComponent;
}());

var NgxCsvParserModule = /** @class */ (function () {
    function NgxCsvParserModule() {
    }
    NgxCsvParserModule = __decorate([
        NgModule({
            declarations: [NgxCsvParserComponent],
            imports: [],
            providers: [NgxCsvParser],
            exports: [NgxCsvParserComponent]
        })
    ], NgxCsvParserModule);
    return NgxCsvParserModule;
}());

/*
 * Public API Surface of ngx-csv-parser
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxCSVParserError, NgxCsvParser, NgxCsvParserComponent, NgxCsvParserModule };
//# sourceMappingURL=ngx-csv-parser.js.map
